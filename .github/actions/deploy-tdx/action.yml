name: 'TDX Deploy'
description: 'Deploy workload to persistent TDX VM with attestation and EasyEnclave registration'
author: 'TDX GitHub Runner'

branding:
  icon: 'upload-cloud'
  color: 'purple'

inputs:
  service_name:
    description: 'Service name for EasyEnclave registration'
    required: true
  service_description:
    description: 'Description for EasyEnclave registration'
    required: false
    default: ''
  service_url:
    description: 'Public URL of the deployed service'
    required: true
  docker_compose_path:
    description: 'Path to docker-compose.yml'
    required: false
    default: './docker-compose.yml'
  intel_api_key:
    description: 'Intel Trust Authority API key'
    required: true
  intel_api_url:
    description: 'Intel Trust Authority API URL'
    required: false
    default: 'https://api.trustauthority.intel.com'
  source_repo:
    description: 'Source repository URL for registration'
    required: false
    default: ''
  tags:
    description: 'JSON array of tags for EasyEnclave registration'
    required: false
    default: '[]'
  vm_memory_gb:
    description: 'VM memory in GB'
    required: false
    default: '8'
  vm_cpus:
    description: 'Number of VM CPUs'
    required: false
    default: '4'
  image_path:
    description: 'Path to TDX VM image (defaults to pre-built image)'
    required: false
    default: ''
  compose_up_args:
    description: 'Arguments for docker compose up'
    required: false
    default: '--build -d'
  timeout_minutes:
    description: 'Maximum time to wait for VM to be ready'
    required: false
    default: '10'
  health_endpoint:
    description: 'Health check endpoint path'
    required: false
    default: '/health'
  easyenclave_api_url:
    description: 'EasyEnclave API URL'
    required: false
    default: 'https://app.easyenclave.com'

outputs:
  vm_name:
    description: 'Full VM name from tdvirsh'
    value: ${{ steps.launch.outputs.vm_name }}
  share_dir:
    description: 'Shared directory path'
    value: ${{ steps.setup.outputs.share_dir }}
  service_id:
    description: 'EasyEnclave service ID'
    value: ${{ steps.register.outputs.service_id }}
  mrtd:
    description: 'TDX MRTD measurement'
    value: ${{ steps.attest.outputs.mrtd }}
  attestation_json:
    description: 'Full attestation JSON'
    value: ${{ steps.attest.outputs.attestation_json }}

runs:
  using: 'composite'
  steps:
    - name: Validate inputs
      id: validate
      shell: bash
      run: |
        echo "Validating inputs..."

        # Validate service name
        if [ -z "${{ inputs.service_name }}" ]; then
          echo "::error::service_name is required"
          exit 1
        fi

        # Validate service URL
        if [ -z "${{ inputs.service_url }}" ]; then
          echo "::error::service_url is required"
          exit 1
        fi

        # Validate Intel API key
        if [ -z "${{ inputs.intel_api_key }}" ]; then
          echo "::error::intel_api_key is required"
          exit 1
        fi

        # Check compose file
        if [ ! -f "${{ inputs.docker_compose_path }}" ]; then
          echo "::error::Docker compose file not found: ${{ inputs.docker_compose_path }}"
          exit 1
        fi

        # Validate memory/cpu values
        if ! [[ "${{ inputs.vm_memory_gb }}" =~ ^[0-9]+$ ]]; then
          echo "::error::Invalid vm_memory_gb value"
          exit 1
        fi

        if ! [[ "${{ inputs.vm_cpus }}" =~ ^[0-9]+$ ]]; then
          echo "::error::Invalid vm_cpus value"
          exit 1
        fi

        # Validate tags JSON
        if ! echo '${{ inputs.tags }}' | jq -e '.' > /dev/null 2>&1; then
          echo "::error::tags must be valid JSON array"
          exit 1
        fi

        echo "Inputs validated"

    - name: Create shared directory and config
      id: setup
      shell: bash
      run: |
        # Create unique shared directory
        SHARE_DIR="/tmp/tdx-share-$(uuidgen)"
        mkdir -p "$SHARE_DIR"
        echo "share_dir=$SHARE_DIR" >> $GITHUB_OUTPUT
        echo "Created share directory: $SHARE_DIR"

        # Compute compose hash
        COMPOSE_HASH=$(sha256sum "${{ inputs.docker_compose_path }}" | awk '{print $1}')
        echo "compose_hash=$COMPOSE_HASH" >> $GITHUB_OUTPUT

        # Copy compose file and build context
        COMPOSE_DIR=$(dirname "${{ inputs.docker_compose_path }}")

        if [ "$COMPOSE_DIR" = "." ]; then
          # Compose file is in current directory, copy all files
          for item in ./* ./.[!.]* ./..?*; do
            [ -e "$item" ] || continue
            FNAME=$(basename "$item")
            # Skip files we don't need
            [[ "$FNAME" == ".git" ]] && continue
            [[ "$FNAME" == ".github" ]] && continue
            [[ "$FNAME" == "node_modules" ]] && continue
            [[ "$FNAME" == "__pycache__" ]] && continue
            cp -r "$item" "$SHARE_DIR/" 2>/dev/null || true
          done
        else
          # Copy compose directory contents
          for f in "$COMPOSE_DIR"/*; do
            [ -e "$f" ] || continue
            FNAME=$(basename "$f")
            [[ "$FNAME" == ".git" ]] && continue
            [[ "$FNAME" == ".github" ]] && continue
            [[ "$FNAME" == "node_modules" ]] && continue
            [[ "$FNAME" == "__pycache__" ]] && continue
            cp -r "$f" "$SHARE_DIR/" 2>/dev/null || true
          done
          cp "${{ inputs.docker_compose_path }}" "$SHARE_DIR/docker-compose.yml"
        fi

        echo "Copied compose file and build context to $SHARE_DIR/"
        ls -la "$SHARE_DIR/"

        # Write config.json for persistent mode with attestation
        cat > "$SHARE_DIR/config.json" << EOF
        {
          "mode": "persistent",
          "intel_api_key": "${{ inputs.intel_api_key }}",
          "intel_api_url": "${{ inputs.intel_api_url }}",
          "compose_up_args": "${{ inputs.compose_up_args }}",
          "health_endpoint": "${{ inputs.health_endpoint }}"
        }
        EOF

        echo "Config written to $SHARE_DIR/config.json (persistent mode with attestation)"

    - name: Launch TDX VM
      id: launch
      shell: bash
      run: |
        echo "Launching persistent TDX VM..."

        SHARE_DIR="${{ steps.setup.outputs.share_dir }}"

        # Determine image path
        IMAGE_PATH="${{ inputs.image_path }}"
        if [ -z "$IMAGE_PATH" ]; then
          for path in \
            "${GITHUB_WORKSPACE}/vm_images/output/tdx-runner.qcow2" \
            "${TDX_IMAGE_PATH:-/var/lib/tdx/images/tdx-runner.qcow2}" \
            "$HOME/tdx/guest-tools/image/tdx-guest-ubuntu-24.04-generic.qcow2"; do
            if [ -f "$path" ]; then
              IMAGE_PATH="$path"
              break
            fi
          done
        fi

        if [ ! -f "$IMAGE_PATH" ]; then
          echo "::error::TDX image not found. Set image_path input or build image first."
          exit 1
        fi

        echo "Using image: $IMAGE_PATH"

        # Find tdvirsh
        TDVIRSH="${GITHUB_WORKSPACE}/vm_images/guest-tools/tdvirsh"
        if [ ! -f "$TDVIRSH" ]; then
          TDVIRSH="${GITHUB_WORKSPACE}/deps/tdx/guest-tools/tdvirsh"
        fi
        if [ ! -f "$TDVIRSH" ]; then
          TDVIRSH="$(which tdvirsh 2>/dev/null || echo '')"
        fi
        if [ -z "$TDVIRSH" ] || [ ! -f "$TDVIRSH" ]; then
          echo "::error::tdvirsh not found. Run setup_host.sh first."
          exit 1
        fi

        # Launch VM with shared directory
        echo "Launching TDX VM with shared directory: $SHARE_DIR"
        VM_OUTPUT=$("$TDVIRSH" new -i "$IMAGE_PATH" --share-dir "$SHARE_DIR" 2>&1) || {
          echo "::error::Failed to launch TDX VM: $VM_OUTPUT"
          exit 1
        }

        # Parse VM name from output
        VM_NAME=$(echo "$VM_OUTPUT" | grep -oP 'Name:\s+\K\S+' | head -1)
        if [ -z "$VM_NAME" ]; then
          VM_NAME=$(echo "$VM_OUTPUT" | grep -oP 'tdvirsh-\S+' | head -1)
        fi

        if [ -z "$VM_NAME" ]; then
          echo "::error::Could not determine VM name from: $VM_OUTPUT"
          exit 1
        fi

        echo "vm_name=$VM_NAME" >> $GITHUB_OUTPUT
        echo "$VM_NAME" > /tmp/deploy_tdx_vm_name.txt
        echo "$SHARE_DIR" > /tmp/deploy_tdx_share_dir.txt

        echo "TDX VM launched: $VM_NAME"

    - name: Wait for ready
      id: wait
      shell: bash
      run: |
        SHARE_DIR="${{ steps.setup.outputs.share_dir }}"
        TIMEOUT_SECS=$(( ${{ inputs.timeout_minutes }} * 60 ))
        START_TIME=$(date +%s)

        echo "Waiting for VM to be ready..."
        echo "Polling $SHARE_DIR/status for 'ready'..."

        while true; do
          CURRENT_TIME=$(date +%s)
          ELAPSED=$((CURRENT_TIME - START_TIME))

          if [ $ELAPSED -gt $TIMEOUT_SECS ]; then
            echo "::error::Timeout waiting for VM to be ready"
            if [ -f "$SHARE_DIR/error.log" ]; then
              echo "Error log:"
              cat "$SHARE_DIR/error.log"
            fi
            exit 1
          fi

          # Check for error
          if [ -f "$SHARE_DIR/error.log" ]; then
            echo "::error::VM startup failed:"
            cat "$SHARE_DIR/error.log"
            exit 1
          fi

          # Check for ready status
          STATUS=$(cat "$SHARE_DIR/status" 2>/dev/null || echo "booting")
          if [ "$STATUS" = "ready" ]; then
            echo "VM is ready!"
            break
          fi

          echo "Status: $STATUS (elapsed: ${ELAPSED}s)"
          sleep 5
        done

    - name: Wait for attestation
      id: attest
      shell: bash
      run: |
        SHARE_DIR="${{ steps.setup.outputs.share_dir }}"
        ATTESTATION_FILE="$SHARE_DIR/attestation.json"

        echo "Waiting for attestation file..."

        # Wait up to 120 seconds for attestation
        FOUND=false
        for i in {1..60}; do
          if [ -f "$ATTESTATION_FILE" ]; then
            echo "Attestation file found after $((i * 2)) seconds"
            FOUND=true
            break
          fi
          # Check for errors
          if [ -f "$SHARE_DIR/error.log" ]; then
            echo "::error::VM reported error during attestation:"
            cat "$SHARE_DIR/error.log"
            exit 1
          fi
          sleep 2
        done

        if [ "$FOUND" != "true" ]; then
          echo "::error::Attestation file not found after 120 seconds"
          echo "Share directory contents:"
          ls -la "$SHARE_DIR/"
          if [ -f "$SHARE_DIR/status" ]; then
            echo "Status: $(cat "$SHARE_DIR/status")"
          fi
          exit 1
        fi

        # Extract attestation data
        echo "Reading attestation data..."
        ATTESTATION_JSON=$(cat "$ATTESTATION_FILE")
        echo "$ATTESTATION_JSON" | jq .

        MRTD=$(echo "$ATTESTATION_JSON" | jq -r '.tdx.measurements.mrtd // empty')
        ITA_TOKEN=$(echo "$ATTESTATION_JSON" | jq -r '.tdx.intel_ta_token // empty')

        # Validate MRTD is present
        if [ -z "$MRTD" ]; then
          echo "::error::Attestation file exists but MRTD is empty"
          echo "::error::This may indicate TDX quote generation failed"
          exit 1
        fi

        echo "mrtd=$MRTD" >> $GITHUB_OUTPUT
        echo "ita_token=$ITA_TOKEN" >> $GITHUB_OUTPUT
        echo "attestation_json=$(echo "$ATTESTATION_JSON" | jq -c '.')" >> $GITHUB_OUTPUT

        echo "MRTD: ${MRTD:0:32}..."
        if [ -z "$ITA_TOKEN" ]; then
          echo "::error::No Intel TA token in attestation"
          echo "::error::Cannot register without valid attestation"
          exit 1
        fi
        echo "ITA Token: ${ITA_TOKEN:0:50}..."

    - name: Register with EasyEnclave
      id: register
      shell: bash
      run: |
        echo "Registering with EasyEnclave Discovery..."

        # Build source repo URL
        SOURCE_REPO="${{ inputs.source_repo }}"
        if [ -z "$SOURCE_REPO" ]; then
          SOURCE_REPO="https://github.com/${{ github.repository }}"
        fi

        # Get attestation data from previous step
        MRTD="${{ steps.attest.outputs.mrtd }}"
        ITA_TOKEN="${{ steps.attest.outputs.ita_token }}"

        # Build registration payload
        PAYLOAD=$(jq -n \
          --arg name "${{ inputs.service_name }}" \
          --arg desc "${{ inputs.service_description }}" \
          --arg url "${{ inputs.service_url }}" \
          --arg repo "$SOURCE_REPO" \
          --arg commit "${{ github.sha }}" \
          --arg mrtd "$MRTD" \
          --arg token "$ITA_TOKEN" \
          --argjson tags '${{ inputs.tags }}' \
          '{
            name: $name,
            description: (if $desc != "" then $desc else null end),
            endpoints: {prod: $url},
            source_repo: $repo,
            source_commit: $commit,
            tags: $tags,
            mrtd: (if $mrtd != "" then $mrtd else null end),
            intel_ta_token: (if $token != "" then $token else null end)
          }')

        echo "Registration payload:"
        echo "$PAYLOAD" | jq .

        # Register with EasyEnclave
        HTTP_CODE=$(curl -s -w "%{http_code}" -o /tmp/register_response.json \
          -X POST "${{ inputs.easyenclave_api_url }}/api/v1/register" \
          -H "Content-Type: application/json" \
          -d "$PAYLOAD")

        RESPONSE=$(cat /tmp/register_response.json)

        echo "HTTP Status: $HTTP_CODE"
        echo "Response:"
        echo "$RESPONSE" | jq . 2>/dev/null || echo "$RESPONSE"

        # Check HTTP status
        if [[ ! "$HTTP_CODE" =~ ^2 ]]; then
          echo "::error::Registration failed with HTTP $HTTP_CODE"
          echo "::error::Response: $RESPONSE"
          exit 1
        fi

        # Check for service_id in response
        SERVICE_ID=$(echo "$RESPONSE" | jq -r '.service_id // empty')
        if [ -n "$SERVICE_ID" ]; then
          echo "service_id=$SERVICE_ID" >> $GITHUB_OUTPUT
          echo "Successfully registered with service ID: $SERVICE_ID"
        else
          echo "::error::Registration failed - no service_id in response"
          echo "::error::Response: $RESPONSE"
          exit 1
        fi

    - name: Summary
      shell: bash
      run: |
        echo ""
        echo "========================================="
        echo "TDX Deploy Complete"
        echo "========================================="
        echo ""
        echo "VM Name:      ${{ steps.launch.outputs.vm_name }}"
        echo "Share Dir:    ${{ steps.setup.outputs.share_dir }}"
        echo "Service ID:   ${{ steps.register.outputs.service_id }}"
        echo "MRTD:         ${{ steps.attest.outputs.mrtd }}"
        echo ""
        echo "========================================="
        echo "The VM will persist until explicitly deleted."
        echo "To delete: virsh destroy ${{ steps.launch.outputs.vm_name }}"
        echo "========================================="
